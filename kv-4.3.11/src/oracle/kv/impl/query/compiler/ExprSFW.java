/*-
 * Copyright (C) 2011, 2017 Oracle and/or its affiliates. All rights reserved.
 *
 * This file was distributed by Oracle as part of a version of Oracle NoSQL
 * Database made available at:
 *
 * http://www.oracle.com/technetwork/database/database-technologies/nosqldb/downloads/index.html
 *
 * Please see the LICENSE file included in the top-level directory of the
 * appropriate version of Oracle NoSQL Database for a copy of the license and
 * additional information.
 */

package oracle.kv.impl.query.compiler;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import oracle.kv.Direction;
import oracle.kv.impl.api.table.FieldDefFactory;
import oracle.kv.impl.api.table.FieldDefImpl;
import oracle.kv.impl.api.table.FieldMap;
import oracle.kv.impl.api.table.FieldValueImpl;
import oracle.kv.impl.api.table.IndexImpl;
import oracle.kv.impl.api.table.IndexImpl.IndexField;
import oracle.kv.impl.api.table.RecordDefImpl;
import oracle.kv.impl.api.table.TableImpl;
import oracle.kv.impl.api.table.TablePath;
import oracle.kv.impl.query.QueryException;
import oracle.kv.impl.query.types.ExprType;
import oracle.kv.impl.query.types.ExprType.Quantifier;
import oracle.kv.impl.query.types.TypeManager;
import oracle.kv.table.Index;

/**
 * Represents a SELECT-FROM-WHERE query block.
 *
 * theFromClauses:
 * There is a FromClause for each table expression appearing in the FROM clause
 * of the actual query block. For now, the first of these table exprs is always
 * the name of a KVS table (see ExprBaseTable). Any exprs following the first
 * one cannot be table names (i.e., no joins among KVS tables are supported yet)
 *
 * theWhereExpr:
 *
 * theFieldNames:
 *
 * theFieldExprs:
 *
 * theHasSelectASclauses
 * True if any of the SELECT exprs has an associated AS clause. If so, the SFW
 * expr must construct a record for each evaluation of the SELECT clause. The
 * fields value of that record are the values computed by the SELECT exprs.
 * If false and the SELECT contains a single expr, no record is contructed.
 */
class ExprSFW extends Expr {

    class FromClause
    {
        /*
         * The variable defined by the current FromClause
         */
        private final ExprVar theVar;

        /*
         * The "domain expr" of the variable. The variable iterates over the
         * items generated by this expr.
         */
        private Expr theDomainExpr;

        FromClause(Expr domainExpr, String varName) {
            theDomainExpr = domainExpr;
            theDomainExpr.addParent(ExprSFW.this);
            theVar = new ExprVar(theQCB, theSctx, domainExpr.getLocation(),
                                 varName, this);
        }

        Expr getDomainExpr() {
            return theDomainExpr;
        }

        ExprVar getVar() {
            return theVar;
        }
    }

    private int theNumChildren;

    private ArrayList<FromClause> theFromClauses;

    private Expr theWhereExpr;

    private ArrayList<String> theFieldNames;

    private ArrayList<Expr> theFieldExprs;

    private boolean theHasSelectASclauses = true;

    private ArrayList<Expr> theSortExprs;

    private ArrayList<SortSpec> theSortSpecs;

    private boolean theUsePrimaryIndexForSort = false;

    private IndexImpl theSortingIndex = null;

    private Expr theOffsetExpr;

    private Expr theLimitExpr;

    ExprSFW(
        QueryControlBlock qcb,
        StaticContext sctx,
        QueryException.Location location) {

        super(qcb, sctx, ExprKind.SFW, location);
        theFromClauses = new ArrayList<FromClause>(8);
    }

    FromClause addFromClause(Expr domainExpr, String varName) {
        FromClause fc = this.new FromClause(domainExpr, varName);
        theFromClauses.add(fc);
        ++theNumChildren;
        return fc;
    }

    void removeFromClause(int i, boolean destroy) {

        FromClause fc = theFromClauses.get(i);
        theFromClauses.remove(i);
        --theNumChildren;
        fc.getDomainExpr().removeParent(this, destroy);
        assert(!fc.getVar().hasParents());
    }

    FromClause getFromClause(int i) {
        return theFromClauses.get(i);
    }

    int getNumVars() {
        return theFromClauses.size();
    }

    ExprVar getVar(int i) {
        return theFromClauses.get(i).getVar();
    }

    Expr getDomainExpr(int i) {
        return theFromClauses.get(i).getDomainExpr();
    }

    void setDomainExpr(int i, Expr newExpr, boolean destroy) {
        FromClause fc = theFromClauses.get(i);
        fc.theDomainExpr.removeParent(this, destroy);
        fc.theDomainExpr = newExpr;
        newExpr.addParent(this);
    }

    /*
     * Check whether the given expr is the domain expr for a variable defined
     * by this SFW expr. If so, return the variable.
     */
    ExprVar findVarForExpr(Expr expr) {

        int numVars = getNumVars();
        for (int i = 0; i < numVars; ++i) {
            if (getVar(i).getDomainExpr() == expr) {
                return getVar(i);
            }
        }

        return null;
    }

    ExprVar getTableVar() {
        return theFromClauses.get(0).getVar();
    }

    TableImpl getTable() {

        assert(getDomainExpr(0).getKind() == ExprKind.BASE_TABLE);

        if (getDomainExpr(0).getKind() == ExprKind.BASE_TABLE) {
            ExprBaseTable tableExpr = (ExprBaseTable)getDomainExpr(0);
            return tableExpr.getTable();
        }

        return null;
    }

    ExprBaseTable getTableExpr() {

        assert(getDomainExpr(0).getKind() == ExprKind.BASE_TABLE);

        if (getDomainExpr(0).getKind() == ExprKind.BASE_TABLE) {
            return (ExprBaseTable)getDomainExpr(0);
        }

        return null;
    }

    void removeUnusedVars() {

        for (int i = theFromClauses.size() - 1; i >= 0; --i) {
            FromClause fc = theFromClauses.get(i);
            ExprVar var = fc.getVar();
            Expr domExpr = fc.getDomainExpr();
            if (var.getNumParents() == 0 && domExpr.isScalar()) {
                removeFromClause(i, true);
            }
        }
    }

    void addWhereClause(Expr condExpr) {

        assert(theWhereExpr == null);

        theWhereExpr = ExprPromote.create(
            null, condExpr, TypeManager.BOOLEAN_QSTN());

        theWhereExpr.addParent(ExprSFW.this);
        ++theNumChildren;
    }

    Expr getWhereExpr() {
        return theWhereExpr;
    }

    void setWhereExpr(Expr newExpr, boolean destroy) {
        theWhereExpr.removeParent(this, destroy);
        theWhereExpr = null;
        addWhereClause(newExpr);
    }

    void removeWhereExpr(boolean destroy) {
        theWhereExpr.removeParent(this, destroy);
        theWhereExpr = null;
        --theNumChildren;
    }

    void addSelectClause(
        ArrayList<String> fieldNames,
        ArrayList<Expr> fieldExprs,
        boolean hasAS) {

        assert(fieldNames.size() == fieldExprs.size());
        theFieldNames = fieldNames;
        theFieldExprs = fieldExprs;
        theHasSelectASclauses = hasAS;

        for (int i = 0; i < fieldExprs.size(); ++i) {
            Expr expr = fieldExprs.get(i);

            if (expr.isMultiValued()) {
                ArrayList<Expr> args = new ArrayList<Expr>(1);
                args.add(expr);
                expr = new ExprArrayConstr(theQCB, theSctx, expr.getLocation(),
                                           args, true/*conditional*/);
            }

            expr.addParent(this);
            theFieldExprs.set(i, expr);
        }

        theNumChildren += fieldExprs.size();
    }

    boolean getConstructsSelectRecord() {
        if (theFieldExprs.size() > 1) {
            return true;
        }
        return theHasSelectASclauses;
    }

    boolean hasSelectASclauses() {
        return theHasSelectASclauses;
    }

    Expr getFieldExpr(int i) {
        return theFieldExprs.get(i);
    }

    void setFieldExpr(int i, Expr newExpr, boolean destroy) {

        theFieldExprs.get(i).removeParent(this, destroy);

        if (newExpr.isMultiValued()) {
            ArrayList<Expr> args = new ArrayList<Expr>(1);
            args.add(newExpr);
            newExpr = new ExprArrayConstr(theQCB, theSctx, newExpr.theLocation,
                                          args, true/*conditional*/);
        }

        theFieldExprs.set(i, newExpr);
        newExpr.addParent(this);
    }

    void removeField(int i, boolean destroy) {
        theFieldExprs.get(i).removeParent(this, destroy);
        theFieldExprs.remove(i);
        theFieldNames.remove(i);
        theType = computeType();
        --theNumChildren;
    }

    void addField(String name, Expr expr) {
        expr = ExprPromote.create(null, expr, TypeManager.ANY_QSTN());
        theFieldExprs.add(expr);
        theFieldNames.add(name);
        expr.addParent(this);
        theType = computeType();
        ++theNumChildren;
    }

    String getFieldName(int i) {
        return theFieldNames.get(i);
    }

    int getNumFields() {
        return theFieldExprs.size();
    }

    ArrayList<String> getFieldNames() {
        return theFieldNames;
    }

    String[] getFieldNamesArray() {
        String[] arr = new String[theFieldNames.size()];
        return theFieldNames.toArray(arr);
    }

    void addSortClause(
        ArrayList<Expr> sortExprs,
        ArrayList<SortSpec> sortSpecs) {

        theSortExprs = sortExprs;
        theSortSpecs = sortSpecs;

        for (Expr expr : sortExprs) {
            // TODO: allow arrays as well
            expr = ExprPromote.create(null, expr, TypeManager.ANY_ATOMIC_QSTN());
            expr.addParent(this);
        }

        theNumChildren += theSortExprs.size();
    }

    void removeSort() {

        if (!hasSort()) {
            return;
        }

        while (!theSortExprs.isEmpty()) {
            removeSortExpr(0, true);
        }

        theSortExprs = null;
        theSortSpecs = null;
        theSortingIndex = null;
        theUsePrimaryIndexForSort = false;
    }

    boolean hasSort() {
        return (theSortExprs != null && !theSortExprs.isEmpty());
    }

    boolean hasPrimaryIndexBasedSort() {
        return theUsePrimaryIndexForSort;
    }

    boolean hasSecondaryIndexBasedSort() {
        return theSortingIndex != null;
    }

    IndexImpl getSortingIndex() {
        return theSortingIndex;
    }

    int getNumSortExprs() {
        return (theSortExprs == null ? 0 : theSortExprs.size());
    }

    Expr getSortExpr(int i) {
        return theSortExprs.get(i);
    }

    void setSortExpr(int i, Expr newExpr, boolean destroy) {
        theSortExprs.get(i).removeParent(this, destroy);
        theSortExprs.set(i, newExpr);
        newExpr.addParent(this);
    }

    void removeSortExpr(int i, boolean destroy) {
        Expr sortExpr = theSortExprs.remove(i);
        sortExpr.removeParent(this, destroy);
        theSortSpecs.remove(i);
        --theNumChildren;
    }

    SortSpec[] getSortSpecs() {
        SortSpec[] arr = new SortSpec[theSortSpecs.size()];
        return theSortSpecs.toArray(arr);
    }

    /*
     * Method to find the index to use for the sort and determine the
     * direction, or throw error if no applicable index.
     */
    void analyseSort() {

        if (theSortExprs == null || theSortExprs.isEmpty()) {
            return;
        }

        TableImpl table = getTable();

        if (table == null) {
            throw new QueryException(
                "Order-by cannot be performed because the order-by " +
                "expressions are not consecutive columns of any index",
                getSortExpr(0).getLocation());
        }

        ExprBaseTable tableExpr = getTableExpr();

        TablePath epath = new TablePath(table, null/*path*/);
        IndexField ipath = null;
        int i = 0;

        /*
         * Determine the sort direction and store it in the BaseTableExpr
         */
        SortSpec spec = theSortSpecs.get(0);
        boolean desc = spec.theIsDesc;
        boolean nullsLast = !spec.theNullsFirst;
        Direction direction = (desc ? Direction.REVERSE : Direction.FORWARD);

        for (i = 1; i < theSortSpecs.size(); ++i) {
            spec = theSortSpecs.get(i);
            if (desc != spec.theIsDesc || nullsLast != (!spec.theNullsFirst)) {
                throw new QueryException(
                    "In the current implementation, all order-by specs " +
                    "must have the same ordering direction and the same " +
                    "relative order for NULLs",
                    getSortExpr(i).getLocation());
            }
        }

        tableExpr.setDirection(direction);

        /*
         * Check whether the sort exprs are a prefix of the primary key columns.
         */
        int[] pkPositions = table.getPrimKeyPositions();

        for (i = 0; i < pkPositions.length && i < theSortExprs.size(); ++i) {

            Expr sortExpr = getSortExpr(i);

            if (!ExprUtils.isPrimKeyColumnRef(table, pkPositions[i], sortExpr)) {
                break;
            }
        }

        if (i == theSortExprs.size()) {
            theUsePrimaryIndexForSort = true;

            int numShardKeys = table.getShardKeySize();

            if (i > numShardKeys) {
                while (theSortExprs.size() > numShardKeys) {
                    removeSortExpr(theSortExprs.size() - 1, true/*destroy*/);
                }
            }

            return;
        }

        /*
         * Check whether the sort exprs are a prefix of the columns of some
         * secondary index.
         */
        Map<String, Index> indexes = table.getIndexes();

        for (Map.Entry<String, Index> entry : indexes.entrySet()) {

            IndexImpl index = (IndexImpl)entry.getValue();
            List<IndexField> indexPaths = index.getIndexFields();

            for (i = 0;
                 i < indexPaths.size() && i < theSortExprs.size();
                 ++i) {

                ipath = indexPaths.get(i);
                Expr sortExpr = getSortExpr(i);

                if (ipath.isMultiKey()) {
                    break;
                }

                epath.clear();

                if (!ExprUtils.isIndexColumnRef(table, ipath,
                                                sortExpr, epath)) {
                    break;
                }
            }

            if (i == theSortExprs.size()) {
                theSortingIndex = index;
                if ((desc && nullsLast) || (!desc && !nullsLast)) {
                    throw new QueryException(
                        "NULLs ordering is not compatible with the way " +
                        "NULLs are ordered in the index.");
                }
                return;
            }

            /*
             * Check if the remaining sort exprs are primary-key columns
             * (which exist in the index as well).
             */
            if (i < theSortExprs.size()) {

                for (int j = 0;
                     j < pkPositions.length && i < theSortExprs.size();
                     ++i, ++j) {

                    Expr sortExpr = getSortExpr(i);

                    if (!ExprUtils.isPrimKeyColumnRef(table,
                                                      pkPositions[j],
                                                      sortExpr)) {
                        break;
                    }
                }

                if (i == theSortExprs.size()) {
                    theSortingIndex = index;
                    if ((desc && nullsLast) || (!desc && !nullsLast)) {
                        throw new QueryException(
                            "NULLs ordering is not compatible with the way " +
                            "NULLs are ordered in the index.");
                    }
                    return;
                }
            }
        }

        throw new QueryException(
            "Order-by cannot be performed because the order-by " +
            "expressions are not consecutive columns of any index",
            getSortExpr(0).getLocation());
    }

    /*
     * Method to add the sort expr in the SELECT clause, if not there already.
     * The method is called from the Distributer, when a receive expr is pulled
     * above a SFW expr that has sort. The method returns the positions of the
     * sort exprs in the SELECT list. The positions are stored in the receive
     * expr.
     */
    int[] addSortExprsToSelect() {

        int numFieldExprs = theFieldExprs.size();
        int numSortExprs = theSortExprs.size();

        int[] sortPositions = new int[numSortExprs];

        for (int i = 0; i < numSortExprs; ++i) {

            Expr sortExpr = theSortExprs.get(i);

            int j;
            for (j = 0; j < numFieldExprs; ++j) {
                Expr fieldExpr = theFieldExprs.get(j);
                if (ExprUtils.matchExprs(sortExpr, fieldExpr)) {
                    break;
                }
            }

            if (j == numFieldExprs) {
                theFieldExprs.add(sortExpr);
                theFieldNames.add(theQCB.generateFieldName("sort"));
                sortPositions[i] = theFieldExprs.size() - 1;
                ++theNumChildren;
            } else {
                sortPositions[i] = j;
                sortExpr.removeParent(this, true/*destroy*/);
            }
        }

        theNumChildren -= theSortExprs.size();
        theSortExprs = null;
        theType = computeType();

        return sortPositions;
    }

    void addOffsetLimit(Expr offset, Expr limit) {

        if (offset != null) {
            addOffset(offset);
        }

        if (limit != null) {
            addLimit(limit);
        }
    }

    Expr getOffset() {
        return theOffsetExpr;
    }

    void addOffset(Expr expr) {

        assert(theOffsetExpr == null);

        if (!expr.isConstant()) {
            throw new QueryException("Offset expression is not constant");
        }

        if (expr.getKind() == ExprKind.CONST) {
            FieldValueImpl val = ((ExprConst)expr).getValue();
            if (val.getLong() == 0) {
                return;
            }
        }

        theOffsetExpr = ExprPromote.create(null, expr, TypeManager.LONG_ONE());

        theOffsetExpr.addParent(this);
        ++theNumChildren;
    }

    void removeOffset(boolean destroy) {
        theOffsetExpr.removeParent(this, destroy);
        theOffsetExpr = null;
        --theNumChildren;
    }

    void setOffset(Expr newExpr, boolean destroy) {
        theOffsetExpr.removeParent(this, destroy);
        theOffsetExpr = null;
        --theNumChildren;
        addOffset(newExpr);
    }

    Expr getLimit() {
        return theLimitExpr;
    }

    void addLimit(Expr expr) {

        assert(theLimitExpr == null);

        if (!expr.isConstant()) {
            throw new QueryException("Limit expression is not constant");
        }

        theLimitExpr = ExprPromote.create(null, expr, TypeManager.LONG_ONE());
        theLimitExpr.addParent(this);
        ++theNumChildren;
    }

    void removeLimit(boolean destroy) {
        theLimitExpr.removeParent(this, destroy);
        theLimitExpr = null;
        --theNumChildren;
    }

    void setLimit(Expr newExpr, boolean destroy) {
        theLimitExpr.removeParent(this, destroy);
        theLimitExpr = null;
        --theNumChildren;
        addLimit(newExpr);
    }

    @Override
    int getNumChildren() {
        return theNumChildren;
    }

    int computeNumChildren() {
        return
            theFromClauses.size() +
            (theWhereExpr != null ? 1 : 0) +
            theFieldExprs.size() +
            (theSortExprs != null ? theSortExprs.size() : 0) +
            (theOffsetExpr != null ? 1 : 0) +
            (theLimitExpr != null ? 1 : 0);
    }

    int[] addPrimKeyToSelect() {

        TableImpl table = getTable();

        int[] pkPositions = table.getPrimKeyPositions();
        int numPrimKeyCols = pkPositions.length;
        int numFieldExprs = theFieldExprs.size();
        int[] pkPositionsInSelect = new int[numPrimKeyCols];

        for (int i = 0; i < numPrimKeyCols; ++i) {

            int j;
            for (j = 0; j < numFieldExprs; ++j) {

                Expr fieldExpr = theFieldExprs.get(j);

                if (ExprUtils.isPrimKeyColumnRef(table,
                                                 pkPositions[i],
                                                 fieldExpr)) {
                    break;
                }
            }

            if (j == numFieldExprs) {
                String pkColName = table.getPrimaryKeyColumnName(i);
                Expr primKeyExpr = new ExprFieldStep(getQCB(),
                                                     getSctx(),
                                                     getLocation(),
                                                     getTableVar(),
                                                     pkColName);
                theFieldExprs.add(primKeyExpr);
                theFieldNames.add(theQCB.generateFieldName(pkColName));
                pkPositionsInSelect[i] = theFieldExprs.size() - 1;
                ++theNumChildren;
            } else {
                pkPositionsInSelect[i] = j;
            }
        }

        theType = computeType();

        return pkPositionsInSelect;
    }

    /**
     * For now, SFW always returns a record type even if only one column is
     * selected. This is because we don't have scalar subqueries yet, and
     * without them, the result of SFW is always a tuple with column names,
     * according to the SQL semantics.
     */
    @Override
    ExprType computeType() {

        Quantifier q = getDomainExpr(0).getType().getQuantifier();

        for (int i = 1; i < theFromClauses.size(); ++i) {

            Quantifier q1 = getDomainExpr(i).getType().getQuantifier();

            q = TypeManager.getUnionQuant(q, q1);

            if (q == Quantifier.STAR) {
                break;
            }
        }

        if (theWhereExpr != null) {
            q = TypeManager.getUnionQuant(q, Quantifier.QSTN);
        }

        if (!getConstructsSelectRecord()) {
            ExprType type = TypeManager.createType(getFieldExpr(0).getType(), q);
            if (type.isAnyJson()) {
                theQCB.theHaveJsonConstructors = true;
            }
            return type;
        }

        FieldMap fieldMap = new FieldMap();

        for (int i = 0; i < theFieldNames.size(); ++i) {

            FieldDefImpl fieldDef = theFieldExprs.get(i).getType().getDef();

            if (fieldDef.isJson()) {
                theQCB.theHaveJsonConstructors = true;
            }
            /*
             * TODO: what about nullability? If a field is not nullable, it
             * must have a default value, so we need a method to create a 
             * default default value.
             */
            fieldMap.put(theFieldNames.get(i),
                         fieldDef,
                         true/*nullable*/,
                         null/*defaultValue*/);
        }

        RecordDefImpl recDef = FieldDefFactory.createRecordDef(fieldMap,
                                                               null/*descr*/);
        return TypeManager.createType(recDef, q);
    }

    @Override
    public boolean mayReturnNULL() {

        if (getConstructsSelectRecord()) {
            return false;
        }

        return theFieldExprs.get(0).mayReturnNULL();
    }

    @Override
    void displayContent(StringBuilder sb, QueryFormatter formatter) {

        formatter.indent(sb);
        for (int i = 0; i < theFromClauses.size(); ++i) {
            FromClause fc = theFromClauses.get(i);
            sb.append("FROM-" + i + " :\n");
            fc.getDomainExpr().display(sb, formatter);
            sb.append(" as " + fc.getVar().getName() + "\n\n");
        }

        if (theWhereExpr != null) {
            formatter.indent(sb);
            sb.append("WHERE:\n");
            theWhereExpr.display(sb, formatter);
            sb.append("\n\n");
        }

        formatter.indent(sb);
        sb.append("SELECT:\n");

        for (int i = 0; i < theFieldExprs.size(); ++i) {
            formatter.indent(sb);
            sb.append(theFieldNames.get(i)).append(": \n");
            theFieldExprs.get(i).display(sb, formatter);
            if (i < theFieldExprs.size() - 1) {
                sb.append(",\n");
            }
        }
    }
}
